 # pragma  kernel VertexGive
 #define PI 3.14159265359

float gridSize;
float2 posOnSphere;
float planeLength;
float planetR;

// New parameters for generateComplexGradientNoise
float freqency = 1.0f;
int iterations = 5;
float iterationSize = 2.0f;
float power = 2.0f;
float Intensity = 2.0f;
int whatSide = 1;
float OceanNoiseIntensity;

float _BiomTransotionNum;
float _BiomNoiseFrequency;
float _BiomNoiseIterations;
float _BiomNoiseIterationSize;
float _BiomNoisePower;
float _BiomNoiseIntensity;

struct TypeInfo
{
     int type;
     int whatBiome;
     float rarity;
     int OnSide1JustUp0;
     float plusYpos;
};
RWStructuredBuffer<TypeInfo> typeInfos;

struct objectInfo
{
     float3 pos;
     float4 rot;
     int type;
     int done;
};

AppendStructuredBuffer<objectInfo> resultObjects;

RWStructuredBuffer<float3> positions;
RWStructuredBuffer<float3> normals;
RWStructuredBuffer<float2> UVs;

float hash(float3 p) {
    p = float3(dot(p, float3(127.1, 311.7, 74.7)),
               dot(p, float3(269.5, 183.3, 246.1)),
               dot(p, float3(113.5, 271.9, 124.6)));
    return frac(sin(dot(p, float3(1.0, 1.0, 1.0))) * 43758.5453);
}

// Gradient Noise function
float GenerateGradientNoise(float3 p) {
    float3 i = floor(p);
    float3 f = frac(p);

    // Compute gradients at the cube's corners
    float n000 = hash(i + float3(0, 0, 0));
    float n100 = hash(i + float3(1, 0, 0));
    float n010 = hash(i + float3(0, 1, 0));
    float n110 = hash(i + float3(1, 1, 0));
    float n001 = hash(i + float3(0, 0, 1));
    float n101 = hash(i + float3(1, 0, 1));
    float n011 = hash(i + float3(0, 1, 1));
    float n111 = hash(i + float3(1, 1, 1));

    // Interpolate between the gradients
    float3 fade_xyz = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);
    float n00 = lerp(n000, n100, fade_xyz.x);
    float n01 = lerp(n001, n101, fade_xyz.x);
    float n10 = lerp(n010, n110, fade_xyz.x);
    float n11 = lerp(n011, n111, fade_xyz.x);
    float n0 = lerp(n00, n10, fade_xyz.y);
    float n1 = lerp(n01, n11, fade_xyz.y);
    float n = lerp(n0, n1, fade_xyz.z);

    return n;
}
float3x3 ComputePerpendicularVectors(float3 originalVector)
{
    float3 perpVector1;
    float3 perpVector2;

    // Calculate perpendicular vectors
    if (abs(originalVector.x) < abs(originalVector.y))
    {
        perpVector1 = float3(1.0, -originalVector.z, 0.0);
    }
    else
    {
        perpVector1 = float3(-originalVector.y, 0.0, originalVector.x);
    }

    perpVector1 = normalize(perpVector1);

    // Calculate second perpendicular vector
    perpVector2 = cross(originalVector, perpVector1);

    // Form the matrix
    float3x3 matrixSpace;
    matrixSpace[0] = perpVector1;
    matrixSpace[1] = perpVector2;
    matrixSpace[2] = originalVector; // Keep original vector as the third row/column if needed

    return matrixSpace;
}

float generateComplexGradientNoise(float3 pos, float frequency, int iterations, float iterationSize, float power, float intensity,float oceanNoiseIntensity) {

    float gradientNoiseValue = 0.0;

    float mountenrelativeSize = 1.0;
    float mountenrelativeDistortion = 1.0;

    for (int i = 0; i < iterations; i++) {         
        float gradientNoiseValuePlus = GenerateGradientNoise(pos * frequency * mountenrelativeDistortion) * mountenrelativeSize;
        
        gradientNoiseValue += pow(abs( gradientNoiseValuePlus), power);

        mountenrelativeSize /= iterationSize;
        mountenrelativeDistortion *= iterationSize;
    }
    
    return gradientNoiseValue * intensity *GenerateGradientNoise(pos*oceanNoiseIntensity);
}
float generateComplexBiomGradientNoise(float3 pos, float frequency, int iterations, float iterationSize, float power, float intensity) {

    float gradientNoiseValue = 0.0;

    float mountenrelativeSize = 1.0;
    float mountenrelativeDistortion = 1.0;

    for (int i = 0; i < iterations; i++) {         
        float gradientNoiseValuePlus = GenerateGradientNoise(pos * frequency * mountenrelativeDistortion) * mountenrelativeSize;
        
        gradientNoiseValue += pow(abs( gradientNoiseValuePlus), power);

        mountenrelativeSize /= iterationSize;
        mountenrelativeDistortion *= iterationSize;
    }
    
    return gradientNoiseValue * intensity;
}

float3 CalculatePosOnPlanet(float3 pos) {
    float3 SpherePosition = normalize(pos) * planetR;

    float gradientNoise = generateComplexGradientNoise(SpherePosition, freqency, iterations, iterationSize, power,Intensity,OceanNoiseIntensity);
    return SpherePosition * (1 + (gradientNoise / planetR));
}
float3x3 GeneratePerpendicularDirections(float3 inputDir)
{
    inputDir = normalize(inputDir);
            
    // Generate the first perpendicular direction
    float3 up = abs(inputDir.y) < 0.999 ? float3(0, 1, 0) : float3(1, 0, 0);
    float3 perpendicular1 = normalize(cross(inputDir, up));
            
    // Generate the second perpendicular direction
    float3 perpendicular2 = cross(inputDir, perpendicular1);
            
    // Construct the float3x3 matrix
    return float3x3(perpendicular1, perpendicular2, inputDir);
}
float3 CalculateNormalDir(float3 finalPos)
{
    float3 normalizeDfinalPos = normalize(finalPos);

    float delta = 0.001f; // Small delta for finite differences

    float3x3 NormalPos = GeneratePerpendicularDirections(normalizeDfinalPos);

    // Scale the perpendicular directions by delta
    NormalPos = NormalPos * delta;

    // Calculate positions on the planet
    float3 worldPos1 = CalculatePosOnPlanet(NormalPos[0] + finalPos);
    float3 worldPos2 = CalculatePosOnPlanet(NormalPos[1] + finalPos);

    float3 direction1 = worldPos1 - finalPos;
    float3 direction2 = worldPos2 - finalPos;

    // Calculate the cross product of worldPos1 and worldPos2
    float3 normal = cross(normalize(direction1),normalize( direction2));

    // Return the normalized normal vector
    return normal;
}
float3 FindPerpendicularVector(float3 normal)
{
    // Define a reference vector (not collinear with normal)
    float3 reference = abs(normal.x) < 0.99 ? float3(1, 0, 0) : float3(0, 1, 0);

    // Compute the perpendicular vector using the cross product
    float3 perpendicular = cross(normal, reference);

    // Normalize the result to ensure it is a unit vector
    perpendicular = normalize(perpendicular);

    return perpendicular;
}
float4 NormalToQuaternion(float3 normal)
{
    // Normalize the input normal vector
    normal = normalize(normal);
    
    // Define the forward direction in Unity's coordinate system (float3(0, 0, 1))
    float3 forward = float3(0, 1, 0);
    
    // Calculate the quaternion that rotates the forward vector to match the normal
    float4 quat;
    quat.xyz = cross(forward, normal);  // Get the axis of rotation
    quat.w = sqrt(dot(forward, forward) * dot(normal, normal)) + dot(forward, normal); // Calculate the real part

    // Normalize the quaternion to ensure it represents a valid rotation
    quat = normalize(quat);

    return quat;
}
float biomCalculations(float3 pos)
{
    float BiomNoiseValue = generateComplexBiomGradientNoise(pos+float3(-1000,-1000,-1000), _BiomNoiseFrequency, _BiomNoiseIterations, _BiomNoiseIterationSize, _BiomNoisePower, _BiomNoiseIntensity);

    return pow( BiomNoiseValue / _BiomNoiseIterations ,_BiomTransotionNum);
}

float hash2(float3 p) {
    p = frac(p * 0.1031);
    p += dot(p, p.yzx + 33.33);
    return frac((p.x + p.y) * p.z);
}
void AddResultObjects(float3 pos, float3 InputNormal)
{
    float tileSize = planeLength / gridSize;

    float biomValue =  biomCalculations(pos);

    float DoGenerates[20];

    for (int i = 0; i < typeInfos.Length; i++)
    {
         TypeInfo typeInfo = typeInfos[i];

         float chanceOfGenerating = typeInfo.rarity /tileSize;
        
         if(typeInfo.whatBiome == 0)
         {
            float newBiomValue = clamp ((biomValue)+1,1,1000000);
            chanceOfGenerating = chanceOfGenerating *  newBiomValue;
         }else
         {
            float newBiomValue = clamp ((1/biomValue)+1,1,1000000);
            chanceOfGenerating = chanceOfGenerating *  newBiomValue;
         }     
         
         DoGenerates[i] = hash2(pos+float3(100,100,100)*(i+1))* chanceOfGenerating;    
         
         float dividenum = 10;
         int maxIterations = 10;
         int iteration = 1;
         while(DoGenerates[i] == 0)
         {           
             iteration++;
             DoGenerates[i]  =( hash2(pos+float3(100,100,100)*(i+1)*iteration )* chanceOfGenerating)/dividenum; 
             dividenum*=10;
             if(iteration>maxIterations)
             {
                 DoGenerates[i] = 0.001;
             }
         }
    }
    int what = -1;
    float best = 100000000;
    for (int i = 0; i < typeInfos.Length; i++)
    {
        if(DoGenerates[i] < best){
            best = DoGenerates[i];
            what = i;
        }  
    }
    if(best<1)
    {
        TypeInfo typeInfo = typeInfos[what];  

        objectInfo newObjectInfo;

        newObjectInfo.pos = pos;
        newObjectInfo.type = what ;

        float3 normal;
        if(typeInfo.OnSide1JustUp0 ==1)
        {
            normal = InputNormal;
        }else
        {
            normal = normalize(pos);
        }

        newObjectInfo.pos += normal * typeInfo.plusYpos;

        newObjectInfo.rot = NormalToQuaternion(normal);           

        //newObjectInfo.rot.x = biomValue+1;
        //newObjectInfo.rot.y = 1/biomValue+1;
       // if(best == 0.001)
       // {
       //     newObjectInfo.type = 100;
       //}

        newObjectInfo.done = 1;

        //newObjectInfo.pos.x = DoGenerates[0];
        //newObjectInfo.pos.y = DoGenerates[1];

        resultObjects.Append(newObjectInfo);
    }
}

bool canCreateObjects;

[numthreads(16, 16, 1)]
void VertexGive(uint3 id : SV_DispatchThreadID) {
    float index = id.x * gridSize + id.y;
    float3 CubePosition = float3(0, 0, 0); // Initialize CubePosition

    switch (whatSide) {
        case 1:
            CubePosition = float3((id.x - gridSize / 2), 0, (id.y - gridSize / 2));
            CubePosition = (CubePosition / gridSize) * planeLength + float3(posOnSphere.x , planetR*0.965, posOnSphere.y ); //- float3(0,planeLength/gridSize,0);
            break;

        case 2:
            CubePosition = float3((id.x - gridSize / 2), 0, (id.y - gridSize / 2));
            CubePosition = (CubePosition / gridSize) * planeLength + float3(posOnSphere.x , -planetR, posOnSphere.y );
            break;

        case 3:
            CubePosition = float3((id.x - gridSize / 2), (id.y - gridSize / 2), 0);
            CubePosition = (CubePosition / gridSize) * planeLength + float3(posOnSphere.x, posOnSphere.y , -planetR);//+ float3(0,0,planeLength/gridSize/10);
            break;

        case 4:
            CubePosition = float3((id.x - gridSize / 2), (id.y - gridSize / 2), 0);
            CubePosition = (CubePosition / gridSize) * planeLength + float3(posOnSphere.x, posOnSphere.y , planetR*0.95);//- float3(0,0,planeLength/gridSize);
            break;

        case 5:
            CubePosition = float3(0, (id.x - gridSize / 2), (id.y - gridSize / 2));
            CubePosition = (CubePosition / gridSize) * planeLength + float3(-planetR, posOnSphere.x, posOnSphere.y );
            break;

        default:
            CubePosition = float3(0, (id.x - gridSize / 2), (id.y - gridSize / 2));
            CubePosition = (CubePosition / gridSize) * planeLength + float3(planetR*0.95, posOnSphere.x , posOnSphere.y );//- float3(planeLength/gridSize,0,0);
            break;
    }

    positions[index] = CalculatePosOnPlanet(CubePosition);
    normals[index] = CalculateNormalDir(positions[index]);
    UVs[index] = float2(id.x, id.y);

    if(canCreateObjects == true)
    {
        AddResultObjects(positions[index],normals[index]  );
    }
}
