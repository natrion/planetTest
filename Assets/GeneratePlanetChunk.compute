#pragma kernel VertexGive

float gridSize;
float2 posOnSphere;
float planeLength;
float planetR;

// New parameters for generateComplexGradientNoise
float freqency = 1.0f;
int iterations = 5;
float iterationSize = 2.0f;
float power = 2.0f;
float Intensity = 2.0f;
int whatSide = 1;
float OceanNoiseIntensity;

float _BiomTransotionNum;
float _BiomNoiseFrequency;
float _BiomNoiseIterations;
float _BiomNoiseIterationSize;
float _BiomNoisePower;
float _BiomNoiseIntensity;

struct TypeInfo
{
     int type;
     int whatBiome;
     float rarity;
     int OnSide1JustUp0;
     float plusYpos;
};
RWStructuredBuffer<TypeInfo> typeInfos;

struct objectInfo
{
     float3 pos;
     float4 rot;
     int type;
};

RWStructuredBuffer<int> resultObjectsSize; 
RWStructuredBuffer<objectInfo> resultObjects;

RWStructuredBuffer<float3> positions;
RWStructuredBuffer<float3> normals;
RWStructuredBuffer<float2> UVs;

float hash(float3 p) {
    p = float3(dot(p, float3(127.1, 311.7, 74.7)),
               dot(p, float3(269.5, 183.3, 246.1)),
               dot(p, float3(113.5, 271.9, 124.6)));
    return frac(sin(dot(p, float3(1.0, 1.0, 1.0))) * 43758.5453);
}

// Gradient Noise function
float GenerateGradientNoise(float3 p) {
    float3 i = floor(p);
    float3 f = frac(p);

    // Compute gradients at the cube's corners
    float n000 = hash(i + float3(0, 0, 0));
    float n100 = hash(i + float3(1, 0, 0));
    float n010 = hash(i + float3(0, 1, 0));
    float n110 = hash(i + float3(1, 1, 0));
    float n001 = hash(i + float3(0, 0, 1));
    float n101 = hash(i + float3(1, 0, 1));
    float n011 = hash(i + float3(0, 1, 1));
    float n111 = hash(i + float3(1, 1, 1));

    // Interpolate between the gradients
    float3 fade_xyz = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);
    float n00 = lerp(n000, n100, fade_xyz.x);
    float n01 = lerp(n001, n101, fade_xyz.x);
    float n10 = lerp(n010, n110, fade_xyz.x);
    float n11 = lerp(n011, n111, fade_xyz.x);
    float n0 = lerp(n00, n10, fade_xyz.y);
    float n1 = lerp(n01, n11, fade_xyz.y);
    float n = lerp(n0, n1, fade_xyz.z);

    return n;
}
float3x3 ComputePerpendicularVectors(float3 originalVector)
{
    float3 perpVector1;
    float3 perpVector2;

    // Calculate perpendicular vectors
    if (abs(originalVector.x) < abs(originalVector.y))
    {
        perpVector1 = float3(1.0, -originalVector.z, 0.0);
    }
    else
    {
        perpVector1 = float3(-originalVector.y, 0.0, originalVector.x);
    }

    perpVector1 = normalize(perpVector1);

    // Calculate second perpendicular vector
    perpVector2 = cross(originalVector, perpVector1);

    // Form the matrix
    float3x3 matrixSpace;
    matrixSpace[0] = perpVector1;
    matrixSpace[1] = perpVector2;
    matrixSpace[2] = originalVector; // Keep original vector as the third row/column if needed

    return matrixSpace;
}

float generateComplexGradientNoise(float3 pos, float frequency, int iterations, float iterationSize, float power, float intensity,float oceanNoiseIntensity) {

    float gradientNoiseValue = 0.0;

    float mountenrelativeSize = 1.0;
    float mountenrelativeDistortion = 1.0;

    for (int i = 0; i < iterations; i++) {         
        float gradientNoiseValuePlus = GenerateGradientNoise(pos * frequency * mountenrelativeDistortion) * mountenrelativeSize;
        
        gradientNoiseValue += pow(abs( gradientNoiseValuePlus), power);

        mountenrelativeSize /= iterationSize;
        mountenrelativeDistortion *= iterationSize;
    }
    
    return gradientNoiseValue * intensity *GenerateGradientNoise(pos*oceanNoiseIntensity);
}
float generateComplexBiomGradientNoise(float3 pos, float frequency, int iterations, float iterationSize, float power, float intensity) {

    float gradientNoiseValue = 0.0;

    float mountenrelativeSize = 1.0;
    float mountenrelativeDistortion = 1.0;

    for (int i = 0; i < iterations; i++) {         
        float gradientNoiseValuePlus = GenerateGradientNoise(pos * frequency * mountenrelativeDistortion) * mountenrelativeSize;
        
        gradientNoiseValue += pow(abs( gradientNoiseValuePlus), power);

        mountenrelativeSize /= iterationSize;
        mountenrelativeDistortion *= iterationSize;
    }
    
    return gradientNoiseValue * intensity;
}

float3 CalculatePosOnPlanet(float3 pos) {
    float3 SpherePosition = normalize(pos) * planetR;

    float gradientNoise = generateComplexGradientNoise(SpherePosition, freqency, iterations, iterationSize, power,Intensity,OceanNoiseIntensity);
    return SpherePosition * (1 + (gradientNoise / planetR));
}
float3x3 GeneratePerpendicularDirections(float3 inputDir)
{
    inputDir = normalize(inputDir);
            
    // Generate the first perpendicular direction
    float3 up = abs(inputDir.y) < 0.999 ? float3(0, 1, 0) : float3(1, 0, 0);
    float3 perpendicular1 = normalize(cross(inputDir, up));
            
    // Generate the second perpendicular direction
    float3 perpendicular2 = cross(inputDir, perpendicular1);
            
    // Construct the float3x3 matrix
    return float3x3(perpendicular1, perpendicular2, inputDir);
}
float3 CalculateNormalDir(float3 finalPos)
{
    float3 normalizeDfinalPos = normalize(finalPos);

    float delta = 0.001f; // Small delta for finite differences

    float3x3 NormalPos = GeneratePerpendicularDirections(normalizeDfinalPos);

    // Scale the perpendicular directions by delta
    NormalPos = NormalPos * delta;

    // Calculate positions on the planet
    float3 worldPos1 = CalculatePosOnPlanet(NormalPos[0] + finalPos);
    float3 worldPos2 = CalculatePosOnPlanet(NormalPos[1] + finalPos);

    float3 direction1 = worldPos1 - finalPos;
    float3 direction2 = worldPos2 - finalPos;

    // Calculate the cross product of worldPos1 and worldPos2
    float3 normal = cross(normalize(direction1),normalize( direction2));

    // Return the normalized normal vector
    return normal;
}

float4 NormalToQuaternion(float3 normal)
{
    // Calculate axis and angle to rotate (0, 0, 1) to 'normal'
    float3 axis = cross(float3(0, 0, 1), normal);
    float angle = acos(dot(float3(0, 0, 1), normal));

    // Convert axis-angle to quaternion
    float halfAngle = angle * 0.5;
    float s = sin(halfAngle);
    float4 q;
    q.xyz = axis * s;
    q.w = cos(halfAngle);

    return q;
}
float biomCalculations(float3 pos)
{
    float BiomNoiseValue = generateComplexBiomGradientNoise(pos+float3(-1000,-1000,-1000), _BiomNoiseFrequency, _BiomNoiseIterations, _BiomNoiseIterationSize, _BiomNoisePower, _BiomNoiseIntensity);

    return pow( BiomNoiseValue / _BiomNoiseIterations ,_BiomTransotionNum);
}

void AddResultObjects(float3 pos, float3 normal)
{
    float biomValue = biomCalculations(pos);

    for (int i = 0; i < typeInfos.Length; i++)
    {
         TypeInfo typeInfo = typeInfos[i];

         float chanceOfGenerating = 1;

         if(typeInfo.whatBiome == 0)
         {
             chanceOfGenerating = 100 ; //chanceOfGenerating * (1- biomValue);
         }else
         {
            chanceOfGenerating = chanceOfGenerating *  biomValue;
         }     
         
         float DoGenerate =  chanceOfGenerating;

         if(DoGenerate<1)
         {
            
             resultObjects[resultObjectsSize[0]].pos = pos;
             resultObjects[resultObjectsSize[0]].type = i;

             float3 normal;
             if(typeInfo.OnSide1JustUp0 ==1)
             {
                 normal = normal;
             }else
             {
                 normal = normalize(pos);
             }

             resultObjects[resultObjectsSize[0]].pos += normal * typeInfo.plusYpos;

             resultObjects[resultObjectsSize[0]].rot = NormalToQuaternion(normal);
           
             resultObjectsSize[0] = resultObjectsSize[0] + 1;
         }
    }
}

[numthreads(16, 16, 1)]
void VertexGive(uint3 id : SV_DispatchThreadID) {
    float index = id.x * gridSize + id.y;
    float3 CubePosition = float3(0, 0, 0); // Initialize CubePosition

    switch (whatSide) {
        case 1:
            CubePosition = float3((id.x - gridSize / 2), 0, (id.y - gridSize / 2));
            CubePosition = (CubePosition / gridSize) * planeLength + float3(posOnSphere.x , planetR*0.965, posOnSphere.y ); //- float3(0,planeLength/gridSize,0);
            break;

        case 2:
            CubePosition = float3((id.x - gridSize / 2), 0, (id.y - gridSize / 2));
            CubePosition = (CubePosition / gridSize) * planeLength + float3(posOnSphere.x , -planetR, posOnSphere.y );
            break;

        case 3:
            CubePosition = float3((id.x - gridSize / 2), (id.y - gridSize / 2), 0);
            CubePosition = (CubePosition / gridSize) * planeLength + float3(posOnSphere.x, posOnSphere.y , -planetR);//+ float3(0,0,planeLength/gridSize/10);
            break;

        case 4:
            CubePosition = float3((id.x - gridSize / 2), (id.y - gridSize / 2), 0);
            CubePosition = (CubePosition / gridSize) * planeLength + float3(posOnSphere.x, posOnSphere.y , planetR*0.95);//- float3(0,0,planeLength/gridSize);
            break;

        case 5:
            CubePosition = float3(0, (id.x - gridSize / 2), (id.y - gridSize / 2));
            CubePosition = (CubePosition / gridSize) * planeLength + float3(-planetR, posOnSphere.x, posOnSphere.y );
            break;

        default:
            CubePosition = float3(0, (id.x - gridSize / 2), (id.y - gridSize / 2));
            CubePosition = (CubePosition / gridSize) * planeLength + float3(planetR*0.95, posOnSphere.x , posOnSphere.y );//- float3(planeLength/gridSize,0,0);
            break;
    }

    positions[index] = CalculatePosOnPlanet(CubePosition);
    normals[index] = CalculateNormalDir(positions[index]);
    UVs[index] = float2(id.x, id.y);

    AddResultObjects(positions[index],normals[index]);
}
