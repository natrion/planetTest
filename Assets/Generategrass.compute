#pragma kernel VertexGive

float gridSize;
float2 posOnSphere;
float planeLength;
float planetR;

// New parameters for generateComplexGradientNoise
float freqency = 1.0f;
int iterations = 5;
float iterationSize = 2.0f;
float power = 2.0f;
float Intensity = 2.0f;
int whatSide = 1;
float OceanNoiseIntensity;

RWStructuredBuffer<float4x4> matrixData;

float4x4 CreateTransformationMatrix(float3 position, float3 rotation, float3 scale)
{
    // Convert Euler angles to rotation matrix
    float3x3 rotationMatrix = float3x3(
        cos(rotation.y) * cos(rotation.z), cos(rotation.y) * sin(rotation.z), -sin(rotation.y),
        sin(rotation.x) * sin(rotation.y) * cos(rotation.z) - cos(rotation.x) * sin(rotation.z), sin(rotation.x) * sin(rotation.y) * sin(rotation.z) + cos(rotation.x) * cos(rotation.z), sin(rotation.x) * cos(rotation.y),
        cos(rotation.x) * sin(rotation.y) * cos(rotation.z) + sin(rotation.x) * sin(rotation.z), cos(rotation.x) * sin(rotation.y) * sin(rotation.z) - sin(rotation.x) * cos(rotation.z), cos(rotation.x) * cos(rotation.y)
    );

    // Apply scale to rotation matrix
    rotationMatrix[0] *= scale.x;
    rotationMatrix[1] *= scale.y;
    rotationMatrix[2] *= scale.z;

    // Create 4x4 transformation matrix
    float4x4 transformationMatrix = float4x4(
        float4(rotationMatrix[0], 0.0),
        float4(rotationMatrix[1], 0.0),
        float4(rotationMatrix[2], 0.0),
        float4(position, 1.0)
    );

    return transformationMatrix;
}

float hash(float3 p) {
    p = float3(dot(p, float3(127.1, 311.7, 74.7)),
               dot(p, float3(269.5, 183.3, 246.1)),
               dot(p, float3(113.5, 271.9, 124.6)));
    return frac(sin(dot(p, float3(1.0, 1.0, 1.0))) * 43758.5453);
}

// Gradient Noise function
float GenerateGradientNoise(float3 p) {
    float3 i = floor(p);
    float3 f = frac(p);

    // Compute gradients at the cube's corners
    float n000 = hash(i + float3(0, 0, 0));
    float n100 = hash(i + float3(1, 0, 0));
    float n010 = hash(i + float3(0, 1, 0));
    float n110 = hash(i + float3(1, 1, 0));
    float n001 = hash(i + float3(0, 0, 1));
    float n101 = hash(i + float3(1, 0, 1));
    float n011 = hash(i + float3(0, 1, 1));
    float n111 = hash(i + float3(1, 1, 1));

    // Interpolate between the gradients
    float3 fade_xyz = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);
    float n00 = lerp(n000, n100, fade_xyz.x);
    float n01 = lerp(n001, n101, fade_xyz.x);
    float n10 = lerp(n010, n110, fade_xyz.x);
    float n11 = lerp(n011, n111, fade_xyz.x);
    float n0 = lerp(n00, n10, fade_xyz.y);
    float n1 = lerp(n01, n11, fade_xyz.y);
    float n = lerp(n0, n1, fade_xyz.z);

    return n;
}
float3x3 ComputePerpendicularVectors(float3 originalVector)
{
    float3 perpVector1;
    float3 perpVector2;

    // Calculate perpendicular vectors
    if (abs(originalVector.x) < abs(originalVector.y))
    {
        perpVector1 = float3(1.0, -originalVector.z, 0.0);
    }
    else
    {
        perpVector1 = float3(-originalVector.y, 0.0, originalVector.x);
    }

    perpVector1 = normalize(perpVector1);

    // Calculate second perpendicular vector
    perpVector2 = cross(originalVector, perpVector1);

    // Form the matrix
    float3x3 matrixSpace;
    matrixSpace[0] = perpVector1;
    matrixSpace[1] = perpVector2;
    matrixSpace[2] = originalVector; // Keep original vector as the third row/column if needed

    return matrixSpace;
}

float generateComplexGradientNoise(float3 pos, float frequency, int iterations, float iterationSize, float power, float intensity,float oceanNoiseIntensity) {

    float gradientNoiseValue = 0.0;

    float mountenrelativeSize = 1.0;
    float mountenrelativeDistortion = 1.0;

    for (int i = 0; i < iterations; i++) {         
        float gradientNoiseValuePlus = GenerateGradientNoise(pos * frequency * mountenrelativeDistortion) * mountenrelativeSize;
        
        gradientNoiseValue += pow(abs( gradientNoiseValuePlus), power);

        mountenrelativeSize /= iterationSize;
        mountenrelativeDistortion *= iterationSize;
    }
    
    return gradientNoiseValue * intensity *GenerateGradientNoise(pos*oceanNoiseIntensity);
}

float3 CalculatePosOnPlanet(float3 pos) {
    float3 SpherePosition = normalize(pos) * planetR;

    float gradientNoise = generateComplexGradientNoise(SpherePosition, freqency, iterations, iterationSize, power,Intensity,OceanNoiseIntensity);
    return SpherePosition * (1 + (gradientNoise / planetR));
}


[numthreads(16, 16, 1)]
void VertexGive(uint3 id : SV_DispatchThreadID) {
    float index = id.x * gridSize + id.y;
    float3 CubePosition = float3(0, 0, 0); // Initialize CubePosition

    switch (whatSide) {
        case 1:
            CubePosition = float3((id.x - gridSize / 2), 0, (id.y - gridSize / 2));
            CubePosition = (CubePosition / gridSize) * planeLength + float3(posOnSphere.x , planetR*0.965, posOnSphere.y ); //- float3(0,planeLength/gridSize,0);
            break;

        case 2:
            CubePosition = float3((id.x - gridSize / 2), 0, (id.y - gridSize / 2));
            CubePosition = (CubePosition / gridSize) * planeLength + float3(posOnSphere.x , -planetR, posOnSphere.y );
            break;

        case 3:
            CubePosition = float3((id.x - gridSize / 2), (id.y - gridSize / 2), 0);
            CubePosition = (CubePosition / gridSize) * planeLength + float3(posOnSphere.x, posOnSphere.y , -planetR);//+ float3(0,0,planeLength/gridSize/10);
            break;

        case 4:
            CubePosition = float3((id.x - gridSize / 2), (id.y - gridSize / 2), 0);
            CubePosition = (CubePosition / gridSize) * planeLength + float3(posOnSphere.x, posOnSphere.y , planetR*0.95);//- float3(0,0,planeLength/gridSize);
            break;

        case 5:
            CubePosition = float3(0, (id.x - gridSize / 2), (id.y - gridSize / 2));
            CubePosition = (CubePosition / gridSize) * planeLength + float3(-planetR, posOnSphere.x, posOnSphere.y );
            break;

        default:
            CubePosition = float3(0, (id.x - gridSize / 2), (id.y - gridSize / 2));
            CubePosition = (CubePosition / gridSize) * planeLength + float3(planetR*0.95, posOnSphere.x , posOnSphere.y );//- float3(planeLength/gridSize,0,0);
            break;
    }

    float3 position = CalculatePosOnPlanet(CubePosition);

    matrixData[index] =  CreateTransformationMatrix(position,normalize(position),float3(1,1,1) );
}
